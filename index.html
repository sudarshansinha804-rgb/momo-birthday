<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Momo's Particle Heart</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        #c { display: block; width: 100vw; height: 100vh; }
        #input_video { position: absolute; opacity: 0; pointer-events: none; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff0055; font-family: 'Courier New', sans-serif; font-size: 20px;
            text-align: center; pointer-events: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="loading">INITIALIZING SYSTEM...<br><span style="font-size:12px; color:white;">(Please Allow Camera Access)</span></div>
    <video id="input_video" playsinline></video>
    <canvas id="c"></canvas>

<script type="module">
import * as THREE from 'three';

// --- CONFIGURATION ---
const PARTICLE_COUNT = 40000; // Lowered slightly for safety
const IMAGE_URL = 'image_0.png'; 
const PARTICLE_SIZE = 3.5;

let renderer, scene, camera;
let particleSystem, uniforms;
let handTracker;
let isFist = false;
let handPosition = new THREE.Vector3(9999, 9999, 9999);

// --- SHADERS ---
const vertexShader = `
    uniform float uTime;
    uniform vec3 uHandPos;
    uniform float uIsFist;
    
    attribute vec3 aTargetHeart;
    attribute vec3 aTargetImage;
    attribute vec3 aColorImage;
    attribute float aRandom;
    
    varying vec3 vColor;

    // Simple Noise
    float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

    void main() {
        float morphFactor = smoothstep(0.0, 1.0, uIsFist);
        vec3 targetPos = mix(aTargetHeart, aTargetImage, morphFactor);

        // Movement noise
        vec3 noise = vec3(
            sin(uTime * 0.5 + aRandom * 10.0),
            cos(uTime * 0.3 + aRandom * 20.0),
            sin(uTime * 0.7 + aRandom * 30.0)
        ) * 2.0;
        
        vec3 finalPos = targetPos + noise;

        // Hand Interaction
        float dist = distance(finalPos, uHandPos);
        float radius = 60.0;
        if (dist < radius) {
            vec3 repulsionDir = normalize(finalPos - uHandPos);
            float force = (1.0 - dist / radius) * 40.0;
            finalPos += repulsionDir * force;
        }

        // Color
        vec3 heartColor = mix(vec3(1.0, 0.0, 0.4), vec3(1.0, 0.5, 0.0), aRandom);
        vColor = mix(heartColor, aColorImage, morphFactor);

        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
        gl_PointSize = ${PARTICLE_SIZE.toFixed(1)} * (300.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const fragmentShader = `
    varying vec3 vColor;
    void main() {
        float dist = length(gl_PointCoord - vec2(0.5));
        if (dist > 0.5) discard;
        gl_FragColor = vec4(vColor, 1.0);
    }
`;

async function init() {
    try {
        const canvas = document.querySelector('#c');
        // Basic renderer, removed Bloom for compatibility
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
        // Responsive Camera Z
        camera.position.z = window.innerWidth < 600 ? 600 : 400;

        await createParticleSystem(IMAGE_URL);
        setupMediaPipe();

        window.addEventListener('resize', onWindowResize);
        
        // Hide loader ONLY after everything is ready
        const loader = document.getElementById('loading');
        loader.innerHTML = "SYSTEM READY.<br>WAVE HAND TO START.";
        setTimeout(() => { loader.style.display = 'none'; }, 2000);
        
        animate();

    } catch (error) {
        alert("ERROR: " + error.message);
        console.error(error);
    }
}

async function createParticleSystem(imageUrl) {
    const image = new Image();
    image.crossOrigin = "Anonymous"; // Fix for some image loading issues
    image.src = imageUrl;
    
    await image.decode().catch(err => { throw new Error("Could not load image_0.png. Check filename!"); });

    const imgCanvas = document.createElement('canvas');
    const ctx = imgCanvas.getContext('2d');
    imgCanvas.width = image.width;
    imgCanvas.height = image.height;
    ctx.drawImage(image, 0, 0);
    const imgData = ctx.getImageData(0, 0, image.width, image.height);

    const positions = [];
    const imagePositions = [];
    const imageColors = [];
    const randoms = [];

    const ratio = image.width / image.height;
    const gridY = Math.sqrt(PARTICLE_COUNT / ratio);
    const gridX = gridY * ratio;
    const stepX = image.width / gridX;
    const stepY = image.height / gridY;

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        // Image Data
        const gx = (i % Math.floor(gridX));
        const gy = Math.floor(i / Math.floor(gridX));
        const pixelX = Math.floor(gx * stepX);
        const pixelY = Math.floor(gy * stepY);
        const pixelIndex = (pixelY * image.width + pixelX) * 4;

        if(pixelIndex < imgData.data.length) {
            imagePositions.push((pixelX - image.width/2) * 0.5);
            imagePositions.push(-(pixelY - image.height/2) * 0.5);
            imagePositions.push(0);
            
            imageColors.push(imgData.data[pixelIndex] / 255);
            imageColors.push(imgData.data[pixelIndex + 1] / 255);
            imageColors.push(imgData.data[pixelIndex + 2] / 255);
        } else {
             imagePositions.push(0,0,0); imageColors.push(0,0,0);
        }

        // Heart Data
        const t = Math.random() * Math.PI * 2;
        const r = Math.pow(Math.random(), 0.3) * 10.0;
        let x = 16 * Math.pow(Math.sin(t), 3);
        let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
        let z = (Math.random() - 0.5) * 10.0;
        positions.push(x * r, y * r, z * r);
        randoms.push(Math.random());
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('aTargetHeart', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('aTargetImage', new THREE.Float32BufferAttribute(imagePositions, 3));
    geometry.setAttribute('aColorImage', new THREE.Float32BufferAttribute(imageColors, 3));
    geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));

    uniforms = {
        uTime: { value: 0 },
        uHandPos: { value: new THREE.Vector3(9999, 9999, 9999) },
        uIsFist: { value: 0.0 }
    };

    const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });

    particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);
}

function setupMediaPipe() {
    const videoElement = document.getElementById('input_video');
    handTracker = new Hands({locateFile: (file) => \`https://cdn.jsdelivr.net/npm/@mediapipe/hands/\${file}\`});
    
    handTracker.setOptions({
        maxNumHands: 1,
        modelComplexity: 0, // Faster
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    handTracker.onResults((results) => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const x = (1.0 - landmarks[8].x) * 2.0 - 1.0; 
            const y = (1.0 - landmarks[8].y) * 2.0 - 1.0;
            const z = -landmarks[8].z * 2.0; 
            
            // Adjust sensitivity for interaction
            handPosition.lerp(new THREE.Vector3(x * 300, y * 300, z * 100), 0.3);

            // Fist detection
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let rolled = 0;
            tips.forEach(tipIdx => {
                const tip = landmarks[tipIdx];
                const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                if (d < 0.25) rolled++; 
            });
            isFist = rolled >= 3;
        } else {
            handPosition.lerp(new THREE.Vector3(9999, 9999, 9999), 0.1);
            isFist = false;
        }
    });

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await handTracker.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraUtils.start();
}

function animate() {
    requestAnimationFrame(animate);
    if (uniforms) {
        uniforms.uTime.value += 0.01;
        uniforms.uHandPos.value.copy(handPosition);
        uniforms.uIsFist.value = THREE.MathUtils.lerp(uniforms.uIsFist.value, isFist ? 1.0 : 0.0, 0.1);
        scene.rotation.y += 0.001;
    }
    renderer.render(scene, camera);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

init();
</script>
</body>
</html>
